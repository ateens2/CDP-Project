# CDP-Project: 탄소 감축 대시보드

2025-1 인하대학교 컴퓨터공학과 졸업과제

## 1. 📖 프로젝트 개요

본 프로젝트는 기업이 친환경 제품 판매를 통해 달성한 탄소 감축 성과를 정량적으로 분석하고 시각화하는 웹 대시보드입니다. 사용자는 자신의 Google Sheets에 있는 판매 데이터를 연동하여, 복잡한 계산 과정 없이 직관적인 차트와 핵심 지표로 환경 기여도를 확인할 수 있습니다.

AI 필드 매핑, 자동화된 데이터 표준화 및 탄소 감축량 계산 기능을 통해 데이터 분석의 진입 장벽을 낮추고, 기업이 지속 가능한 경영 전략을 수립하는 데 필요한 데이터 기반의 인사이트를 제공하는 것을 목표로 합니다.

## 2. ✨ 핵심 기능

-   **Google Sheets 데이터 연동**: 사용자의 판매 데이터가 담긴 Google Sheets를 안전하게 연동합니다.
-   **AI 필드 매핑**: 비표준적인 열(Column) 이름을 가진 시트라도 AI가 자동으로 분석하여 표준 필드에 매핑합니다.
-   **자동 데이터 처리 및 계산**: 클릭 한 번으로 원본 데이터를 표준화하고, 제품별/주문별 탄소 감축량을 자동으로 계산하여 시트에 기록합니다.
-   **탄소 감축 성과 시각화**: 총 감축량, 나무 심기 효과, 친환경 제품 판매율 등 핵심 지표를 요약 카드로 제공합니다.
-   **심층 분석 차트**: 월별 감축 추이, 카테고리별 기여도, 고객 세그먼트별 영향 등 다양한 차트로 다각적인 분석을 지원합니다.
-   **데이터 캐싱**: 최초 분석 후 계산 결과를 별도 시트에 저장하여, 이후 대시보드 로딩 속도를 대폭 향상시킵니다.

## 3. 🏗️ 아키텍처

본 프로젝트는 프론트엔드와 백엔드가 분리된 하이브리드 아키텍처를 채택하고 있습니다.

-   **Frontend (React)**:
    -   Vite 기반의 React SPA(Single Page Application)로 모든 UI와 사용자 상호작용을 담당합니다.
    -   `Chart.js`를 활용하여 데이터를 시각화하고, Google API 클라이언트를 통해 인증된 데이터를 조회합니다.
    -   대시보드는 백엔드가 사전 계산한 데이터를 읽어와 보여주는 역할을 합니다.
-   **Backend (Node.js/Express)**:
    -   사용자 인증(세션 관리), Google Sheets API와의 통신을 중계하는 프록시 역할을 합니다.
    -   **데이터 처리 파이프라인의 핵심**으로, AI 필드 매핑, 데이터 표준화, 탄소 감축량 계산 등 복잡한 로직을 모두 수행합니다.
    -   Python 스크립트(`ai/main.py`)를 실행하여 AI 필드 매핑을 처리합니다.
-   **Data Sources**:
    -   **사용자 Google Sheet**: 사용자가 제공하는 원본 판매 데이터가 저장된 시트입니다.
    -   **로컬 CSV 데이터**: 백엔드 서버에 저장된 두 개의 CSV 파일은 탄소 감축량 계산의 기준이 됩니다.
        -   `data/생활용품 탄소배출량.csv`: 개별 제품의 이름, 카테고리, 탄소 배출 계수(`emission_factor`), 가중치(`weight_factor`) 정보가 담긴 마스터 데이터입니다.
        -   `data/카테고리 별 기준 제품.csv`: 각 카테고리별로 탄소 감축량을 비교하기 위한 '기준 제품'의 정보가 담겨 있습니다.

## 4. 🔄 데이터 워크플로우 (End-to-End)

사용자가 원본 데이터를 업로드하고 대시보드를 확인하기까지의 전체 데이터 흐름입니다.

### 1단계: 사용자 인증 및 초기 설정

1.  사용자는 Google 계정으로 로그인하여 애플리케이션에 인증합니다.
2.  `Workspace` 페이지에서 **"Google Drive에서 스프레드시트 선택"** 버튼을 클릭합니다.
3.  Google Drive 파일 선택기가 나타나면, 분석할 판매 데이터가 포함된 스프레드시트를 선택합니다.
4.  선택된 시트의 ID와 이름이 프론트엔드에 표시되고, 백엔드 서버에 저장되어 사용자와 시트 정보가 연결됩니다.

### 2단계: 데이터 표준화 (AI 필드 매핑)

1.  사용자가 **"AI 필드 매핑"** 버튼을 클릭하면, 백엔드의 `/api/sheets/map-fields` 엔드포인트가 호출됩니다.
2.  백엔드는 원본 시트의 헤더(열 이름)를 가져와 `ai/main.py` Python 스크립트에 전달합니다.
3.  Python 스크립트는 헤더 이름을 분석하여 '주문자명', '상품명', '주문_일자' 등 시스템이 필요로 하는 **표준 필드로 자동 매핑**합니다.
4.  매핑 결과를 바탕으로, 백엔드는 사용자의 Google Sheet 내에 **`제품_판매_기록`**과 **`고객_정보`**라는 두 개의 새로운 시트를 생성합니다.
5.  백엔드는 원본 시트의 데이터를 읽어와, 매핑된 정보에 따라 열 순서를 재배치하고 정제하여 이 두 개의 새로운 시트에 채워 넣습니다. 이로써 모든 데이터가 분석 가능한 표준 형식으로 변환됩니다.

### 3단계: 핵심 탄소 감축량 계산 (백엔드)

이 단계는 2단계 직후 백엔드에서 자동으로 실행되며, 전체 시스템의 핵심 로직입니다.

1.  **기준 데이터 로드**: 백엔드는 서버의 로컬 CSV 파일들(`생활용품 탄소배출량.csv`, `카테고리 별 기준 제품.csv`)을 읽어 메모리에 로드합니다.
2.  **판매 기록 순회**: 표준화된 `제품_판매_기록` 시트의 모든 행(개별 주문)을 순회합니다.
3.  **제품 매칭 및 계산**:
    -   각 주문에 포함된 상품명과 로컬 CSV 데이터의 상품명을 비교하여 매칭합니다. (정확한 매칭 실패 시, `README.md`의 '제품명 매칭 알고리즘'에 따라 유사도 매칭 수행)
    -   매칭된 제품 정보와 해당 카테고리의 '기준 제품' 정보를 가져옵니다.
    -   `README.md`의 핵심 공식에 따라 **개별 제품의 탄소 감축량을 계산**합니다.
4.  **결과 기록**: 계산된 탄소 감축량은 `제품_판매_기록` 시트의 오른쪽에 **`제품별_탄소_감축_점수`**와 **`총_탄소_감축_점수`**라는 두 개의 새로운 열에 기록됩니다.

### 4단계: 고객 데이터 보강

1.  모든 판매 기록의 탄소 감축량 계산이 완료되면, 백엔드는 각 고객별로 데이터를 집계합니다.
2.  고객별 `총_탄소_감축_점수`의 합계를 계산하고, 점수에 따라 **'탄소 감축 등급'** (예: Stone, Bronze, Gold)을 부여합니다.
3.  고객의 총 구매 횟수, 총 구매 금액, 마지막 구매일과 함께 계산된 탄소 점수와 등급을 `고객_정보` 시트에 업데이트하여 고객 데이터를 풍부하게 만듭니다.

### 5단계: 대시보드 데이터 로딩 및 캐싱

1.  사용자가 `탄소 감축 현황` 페이지에 처음 접속하면, `CarbonImpactDashboard.jsx` 컴포넌트가 로드됩니다.
2.  컴포넌트는 `제품_판매_기록`과 `고객_정보` 시트에서 모든 사전 계산된 데이터를 읽어옵니다.
3.  읽어온 데이터를 최종 집계하여 대시보드에 필요한 핵심 지표(KPI)와 차트 데이터를 생성합니다.
4.  **(캐싱)** 성능 향상을 위해, 집계된 최종 데이터를 **`탄소_감축`**이라는 별도의 시트에 저장합니다.
5.  이후 사용자가 대시보드에 다시 방문하면, 2-3단계의 무거운 계산을 건너뛰고 `탄소_감축` 시트에서 캐시된 데이터를 바로 읽어와 매우 빠른 속도로 대시보드를 표시합니다. 데이터 업데이트가 필요할 경우, 사용자는 '데이터 업데이트' 버튼을 눌러 2~4단계를 수동으로 재실행할 수 있습니다.

## 5. 📊 핵심 지표 계산 기준

대시보드에 표시되는 각 지표는 `제품_판매_기록`과 `고객_정보` 시트에 사전 계산된 데이터를 기반으로 다음과 같이 계산됩니다.

### 1. 총 탄소 감축량 (kg CO₂e)

-   **계산 기반**: `제품_판매_기록` 시트의 `총_탄소_감축_점수` 열의 총합.
-   **계산 공식 (백엔드에서 사전 계산)**:
    ```
    각 판매 건별 탄소 감축량 = Σ ((카테고리 기준 제품의 총 탄소 배출량 - 판매 제품의 총 탄소 배출량) × 수량)
    // 총 탄소 배출량 = emission_factor × weight_factor
    ```
-   **조건**: 전체 판매 데이터 기준으로 계산됩니다.

### 2. 나무 그루 수 (그루)

-   **계산 공식**: `Math.round(총 탄소 감축량 / 22)`
-   **기준**: 30년생 소나무 1그루가 연간 흡수하는 이산화탄소량(22kg) 기준입니다.

### 3. 친환경 제품 판매율 (%)

-   **친환경 제품 기준**: `제품_판매_기록` 시트의 `총_탄소_감축_점수`가 0보다 큰 제품.
-   **계산 방식**: 3가지 기준의 가중평균 (올해 데이터 기준)
    -   **건수 기준 (20%)**: 친환경 제품 판매 건수 / 전체 판매 건수
    -   **수량 기준 (40%)**: 친환경 제품 판매 수량 / 전체 판매 수량
    -   **매출 기준 (40%)**: 친환경 제품 매출액 / 전체 매출액
-   **최종 공식**: `(건수비율 × 0.2) + (수량비율 × 0.4) + (매출비율 × 0.4)`

### 4. 고객 환경 참여도 (%)

-   **분류 기준** (전체 고객 대상):
    -   **기본 참여**: 친환경 제품을 1회 이상 구매한 고객
    -   **활성 참여**: 친환경 제품을 3회 이상 구매한 고객
    -   **헌신적 참여**: 전체 구매 건수 중 친환경 제품 구매 건수 비율이 50% 이상인 고객
-   **표시 값**: `(기본 참여 고객 비율 + 활성 참여 고객 비율 + 헌신적 참여 고객 비율) / 3`

## 6. 🛠️ 로컬에서 실행하기

### Backend

```bash
# 백엔드 디렉토리로 이동
cd backend

# 의존성 설치
npm install

# .env 파일 생성 및 환경 변수 설정
# (VITE_GOOGLE_CLIENT_ID, VITE_GOOGLE_API_KEY, DB 정보 등)

# 백엔드 서버 실행
npm start
```

### Frontend

```bash
# 프론트엔드 디렉토리로 이동
cd frontend

# 의존성 설치
npm install

# .env 파일 생성 및 환경 변수 설정
# (VITE_GOOGLE_CLIENT_ID, VITE_GOOGLE_API_KEY, VITE_BACKEND_URL 등)

# 프론트엔드 개발 서버 실행
npm run dev
```

## 🗂️ 데이터 구조

### 제품_판매_기록 시트 (현재 구조)

| 컬럼 | 인덱스 | 필드명 | 설명 |
| --- | --- | --- | --- |
| A | 0 | 주문_번호 | 주문 고유 번호 |
| B | 1 | 주문자명 | 고객 이름 |
| C | 2 | 고객ID | 고객 고유 식별자 |
| D | 3 | 주문_일자 | 주문 날짜 |
| E | 4 | 상품명 | 구매한 제품명 |
| F | 5 | 카테고리 | 제품 카테고리 |
| G | 6 | 수량 | 구매 수량 |
| H | 7 | 총_주문_금액 | 총 주문 금액 |
| I | 8 | 결제방법 | 결제 수단 |

-   각 행의 상품명, 카테고리, 수량은 쉼표로 구분

### 고객_정보 시트 (현재 구조)

| 컬럼 | 인덱스 | 필드명 | 설명 |
| --- | --- | --- | --- |
| A | 0 | 고객ID | 고객 고유 식별자 |
| B | 1 | 고객명 | 고객 이름 |
| C | 2 | 이메일 | 고객 이메일 |
| D | 3 | 연락처 | 고객 연락처 |
| E | 4 | 주소 | 고객 주소 |
| F | 5 | 생년월일 | 고객 생년월일 |
| G | 6 | 성별 | 고객 성별 |
| H | 7 | 가입일 | 서비스 가입일 |
| I | 8 | 탄소_감축_등급 | 탄소 감축 등급 |

## 🔧 제품명 매칭 알고리즘

### 1단계: 정확 매칭

```javascript
normalizeProductName(carbonProduct) === normalizeProductName(saleProduct);
```

### 2단계: 키워드 매칭

```javascript
// 3글자 이상의 경우에만 포함 관계 확인
normalizedCarbonProduct.includes(normalizedSaleProduct) ||
  normalizedSaleProduct.includes(normalizedCarbonProduct);
```

### 3단계: 카테고리 매칭

```javascript
// 판매 데이터의 카테고리 필드와 키워드 매핑
categoryKeywords = {
  컵류: ["컵", "cup", "텀블러", "머그"],
  포장: ["포장", "봉투", "bag", "박스"],
  병류: ["병", "보틀", "bottle", "물병"],
  용기: ["용기", "container", "도시락"],
};
```

### 정규화 함수

```javascript
function normalizeProductName(name) {
  return name
    .toLowerCase()
    .replace(/\s+/g, "") // 공백 제거
    .replace(/[()]/g, "") // 괄호 제거
    .replace(/[0-9]+ml|[0-9]+g|[0-9]+개/g, ""); // 용량/수량 표기 제거
}
```
test for changed directory